from __future__ import annotations

import uuid
from typing import Any, AsyncIterator, Awaitable, Callable, Dict, List, Optional

from agent.realtime.websocket_manager import WebSocketManager

# Implement this here more cleanly (use existing websocket connection and use config)
# write useful wrappers for all used types of events
class MessageManager:
    """
    High-level message manager for OpenAI Realtime API conversations.
    
    Handles session management, conversation items, responses, and audio streaming
    over a WebSocket connection managed by WebSocketManager.
    """

    def __init__(
        self,
        ws_manager: WebSocketManager,
        *,
        system_instructions: str = "You are a helpful AI assistant.",
        voice: str = "alloy",
        temperature: float = 0.7,
        modalities: List[str] = None,
        turn_detection_type: str = "server_vad",
        input_audio_format: str = "pcm16",
        output_audio_format: str = "pcm16",
    ):
        self.ws_manager = ws_manager
        self.system_instructions = system_instructions
        self.voice = voice
        self.temperature = temperature
        self.modalities = modalities or ["text", "audio"]
        self.turn_detection_type = turn_detection_type
        self.input_audio_format = input_audio_format
        self.output_audio_format = output_audio_format
        
        # Session state
        self.session_id: Optional[str] = None
        self.is_session_initialized = False
        self._running = False

    async def connect_and_initialize(self) -> bool:
        """
        Connect to WebSocket and initialize the Realtime session.
        
        Returns:
            True if connection and session initialization successful, False otherwise.
        """
        try:
            # Establish WebSocket connection
            connected = await self.ws_manager.create_connection()
            if not connected:
                return False

            # Wait for session.created event
            session_created = await self.ws_manager.wait_for_event("session.created")
            if not session_created:
                await self.ws_manager.close()
                return False

            self.session_id = session_created.get("session", {}).get("id")
            
            # Initialize session with our configuration
            success = await self._initialize_session()
            if success:
                self.is_session_initialized = True
                
            return success

        except Exception as e:
            await self.ws_manager.close()
            raise RuntimeError(f"Failed to connect and initialize: {e}") from e

    async def disconnect(self) -> None:
        """Close the WebSocket connection gracefully."""
        self._running = False
        await self.ws_manager.close()
        self.is_session_initialized = False
        self.session_id = None

    def is_connected(self) -> bool:
        """Check if WebSocket is connected and session is initialized."""
        return self.ws_manager.is_connected() and self.is_session_initialized

    # Session Management
    
    async def _initialize_session(self) -> bool:
        """Send session.update to configure the Realtime session."""
        session_config = self._build_session_config()
        
        try:
            await self.ws_manager.send_json(session_config)
            
            # Wait for session.updated confirmation
            session_updated = await self.ws_manager.wait_for_event("session.updated")
            return session_updated is not None
            
        except Exception:
            return False

    def _build_session_config(self) -> Dict[str, Any]:
        """Build the session.update event configuration."""
        config = {
            "type": "session.update",
            "event_id": str(uuid.uuid4()),
            "session": {
                "modalities": self.modalities,
                "instructions": self.system_instructions,
                "voice": self.voice,
                "temperature": self.temperature,
                "input_audio_format": self.input_audio_format,
                "output_audio_format": self.output_audio_format,
            }
        }
        
        # Configure turn detection
        if self.turn_detection_type == "server_vad":
            config["session"]["turn_detection"] = {
                "type": "server_vad",
                "threshold": 0.5,
                "prefix_padding_ms": 300,
                "silence_duration_ms": 500,
            }
        elif self.turn_detection_type is None:
            config["session"]["turn_detection"] = None
        else:
            config["session"]["turn_detection"] = {"type": self.turn_detection_type}
            
        return config

    async def update_session(
        self, 
        *, 
        instructions: str = None,
        voice: str = None,
        temperature: float = None,
        modalities: List[str] = None,
    ) -> bool:
        """Update session configuration during an active session."""
        if not self.is_connected():
            raise RuntimeError("Session not initialized")

        updates = {}
        if instructions is not None:
            updates["instructions"] = instructions
            self.system_instructions = instructions
        if voice is not None:
            updates["voice"] = voice
            self.voice = voice
        if temperature is not None:
            updates["temperature"] = temperature
            self.temperature = temperature
        if modalities is not None:
            updates["modalities"] = modalities
            self.modalities = modalities

        if not updates:
            return True

        event = {
            "type": "session.update",
            "event_id": str(uuid.uuid4()),
            "session": updates
        }

        try:
            await self.ws_manager.send_json(event)
            session_updated = await self.ws_manager.wait_for_event("session.updated")
            return session_updated is not None
        except Exception:
            return False

    # Conversation Management

    async def add_text_message(self, text: str, role: str = "user") -> bool:
        """Add a text message to the conversation."""
        if not self.is_connected():
            raise RuntimeError("Session not initialized")

        event = {
            "type": "conversation.item.create",
            "event_id": str(uuid.uuid4()),
            "item": {
                "type": "message",
                "role": role,
                "content": [
                    {
                        "type": "input_text",
                        "text": text,
                    }
                ],
            },
        }

        try:
            await self.ws_manager.send_json(event)
            return True
        except Exception:
            return False

    async def add_audio_message(self, base64_audio: str, role: str = "user") -> bool:
        """Add an audio message to the conversation."""
        if not self.is_connected():
            raise RuntimeError("Session not initialized")

        event = {
            "type": "conversation.item.create",
            "event_id": str(uuid.uuid4()),
            "item": {
                "type": "message",
                "role": role,
                "content": [
                    {
                        "type": "input_audio",
                        "audio": base64_audio,
                    }
                ],
            },
        }

        try:
            await self.ws_manager.send_json(event)
            return True
        except Exception:
            return False

    # Response Generation

    async def create_response(
        self, 
        *,
        modalities: List[str] = None,
        instructions: str = None,
        temperature: float = None,
    ) -> bool:
        """Request the model to create a response."""
        if not self.is_connected():
            raise RuntimeError("Session not initialized")

        event = {
            "type": "response.create",
            "event_id": str(uuid.uuid4()),
            "response": {}
        }

        if modalities is not None:
            event["response"]["modalities"] = modalities
        if instructions is not None:
            event["response"]["instructions"] = instructions
        if temperature is not None:
            event["response"]["temperature"] = temperature

        try:
            await self.ws_manager.send_json(event)
            return True
        except Exception:
            return False

    # Audio Buffer Management

    async def append_audio_buffer(self, base64_audio: str) -> bool:
        """Append audio data to the input buffer."""
        if not self.is_connected():
            raise RuntimeError("Session not initialized")

        event = {
            "type": "input_audio_buffer.append",
            "event_id": str(uuid.uuid4()),
            "audio": base64_audio,
        }

        try:
            await self.ws_manager.send_json(event)
            return True
        except Exception:
            return False

    async def commit_audio_buffer(self) -> bool:
        """Commit the current audio buffer to create a conversation item."""
        if not self.is_connected():
            raise RuntimeError("Session not initialized")

        event = {
            "type": "input_audio_buffer.commit",
            "event_id": str(uuid.uuid4()),
        }

        try:
            await self.ws_manager.send_json(event)
            return True
        except Exception:
            return False

    async def clear_audio_buffer(self) -> bool:
        """Clear the input audio buffer."""
        if not self.is_connected():
            raise RuntimeError("Session not initialized")

        event = {
            "type": "input_audio_buffer.clear",
            "event_id": str(uuid.uuid4()),
        }

        try:
            await self.ws_manager.send_json(event)
            return True
        except Exception:
            return False

    # Message Streaming and Event Handling

    async def listen_for_events(
        self,
        *,
        on_message: Callable[[Dict[str, Any]], Awaitable[None]] = None,
        on_audio_delta: Callable[[str], Awaitable[None]] = None,
        on_text_delta: Callable[[str], Awaitable[None]] = None,
        on_response_done: Callable[[Dict[str, Any]], Awaitable[None]] = None,
        on_error: Callable[[Dict[str, Any]], Awaitable[None]] = None,
    ) -> None:
        """
        Listen for incoming WebSocket messages and route to appropriate handlers.
        
        Args:
            on_message: Handler for all incoming messages
            on_audio_delta: Handler for audio streaming chunks
            on_text_delta: Handler for text streaming chunks  
            on_response_done: Handler for completed responses
            on_error: Handler for error events
        """
        if not self.is_connected():
            raise RuntimeError("Session not initialized")

        self._running = True

        async def message_handler(payload: Dict[str, Any] | str | bytes) -> None:
            if not isinstance(payload, dict):
                return

            event_type = payload.get("type")
            
            # Route to specific handlers
            if event_type == "response.audio.delta" and on_audio_delta:
                delta = payload.get("delta", "")
                if delta:
                    await on_audio_delta(delta)
            
            elif event_type == "response.text.delta" and on_text_delta:
                delta = payload.get("delta", "")
                if delta:
                    await on_text_delta(delta)
                    
            elif event_type == "response.done" and on_response_done:
                await on_response_done(payload)
                
            elif event_type == "error" and on_error:
                await on_error(payload)

            # Always call general message handler if provided
            if on_message:
                await on_message(payload)

        def should_continue() -> bool:
            return self._running and self.ws_manager.is_connected()

        await self.ws_manager.receive_messages(
            on_message=message_handler,
            should_continue=should_continue,
        )

    async def get_audio_stream(self) -> AsyncIterator[str]:
        """
        Get an async iterator of base64-encoded audio chunks from response.audio.delta events.
        """
        if not self.is_connected():
            raise RuntimeError("Session not initialized")

        def should_continue() -> bool:
            return self._running and self.ws_manager.is_connected()

        async for audio_chunk in self.ws_manager.receive_base64_stream(
            event_type="response.audio.delta",
            field="delta",
            should_continue=should_continue,
        ):
            yield audio_chunk

    # Utility Methods

    def stop_listening(self) -> None:
        """Stop the event listening loop."""
        self._running = False

    async def send_text_and_get_response(self, text: str) -> Optional[Dict[str, Any]]:
        """
        Convenience method: send text and wait for response.done.
        
        Returns:
            The response.done event dict, or None if failed.
        """
        if not await self.add_text_message(text):
            return None
            
        if not await self.create_response():
            return None
            
        return await self.ws_manager.wait_for_event("response.done")